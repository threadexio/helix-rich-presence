use std::{
    fs, io,
    path::{Path, PathBuf},
    process::Stdio,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc, OnceLock,
    },
    thread::sleep,
    time::{Duration, SystemTime, UNIX_EPOCH},
};

use discord_presence::Client;
use tokio::process::{Child, Command};
use tokio::time::{interval, MissedTickBehavior};

const APP_ID: u64 = 1339918035842105417;
const UPDATE_INTERVAL: Duration = Duration::from_secs(1);

#[tokio::main(flavor = "current_thread")]
async fn main() {
    let mut helix = Command::new("hx")
        .stdin(Stdio::inherit())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .kill_on_drop(true)
        .spawn()
        .unwrap();

    let mut rpc = Rpc::new(APP_ID).await;

    let mut update = interval(UPDATE_INTERVAL);
    update.set_missed_tick_behavior(MissedTickBehavior::Skip);

    loop {
        tokio::select! {
            _ = helix.wait() => break,
            _ = update.tick() => rpc.update(&helix).await,
        }
    }
}

struct Rpc {
    rpc: Client,
    start: SystemTime,
}

impl Rpc {
    pub async fn new(id: u64) -> Self {
        let start = SystemTime::now();

        let rpc = tokio::task::spawn_blocking(move || {
            let mut rpc = Client::new(id);
            let ready = Arc::new(AtomicBool::new(false));

            let _ready = rpc.on_ready({
                let ready = ready.clone();
                move |_| ready.store(true, Ordering::Relaxed)
            });

            rpc.start();

            while !ready.load(Ordering::Relaxed) {
                sleep(Duration::from_secs(1));
            }

            rpc
        })
        .await
        .unwrap();

        Self { rpc, start }
    }

    pub async fn update(&mut self, helix: &Child) {
        let cwd = match helix.cwd() {
            Ok(x) => x,
            Err(e) if e.kind() == io::ErrorKind::NotFound => return,
            Err(e) => panic!("{e:#}"),
        };

        let workspace = find_repo_root(&cwd)
            .and_then(|x| x.file_name())
            .map(Path::new)
            .or_else(|| strip_home_dir(&cwd))
            .unwrap_or(cwd.as_path());

        self.rpc
            .set_activity(|x| {
                x.details(format!("In {}", workspace.to_string_lossy()))
                    .timestamps(|x| x.start(self.start.duration_since_epoch().as_secs()))
                    .assets(|x| x.large_image("helix-logo").small_image("edit"))
                    .party(|x| x.size((1, 1)))
                    .instance(true)
            })
            .unwrap();
    }
}

trait ChildExt {
    fn cwd(&self) -> io::Result<PathBuf>;
}

impl ChildExt for Child {
    fn cwd(&self) -> io::Result<PathBuf> {
        let id = self
            .id()
            .ok_or_else(|| io::Error::from(io::ErrorKind::BrokenPipe))?;

        fs::read_link(format!("/proc/{id}/cwd"))
    }
}

trait SystemTimeExt {
    fn duration_since_epoch(&self) -> Duration;
}

impl SystemTimeExt for SystemTime {
    fn duration_since_epoch(&self) -> Duration {
        self.duration_since(UNIX_EPOCH).unwrap()
    }
}

fn find_repo_root(path: &Path) -> Option<&Path> {
    path.ancestors().find(|root| root.join(".git").is_dir())
}

fn strip_home_dir(path: &Path) -> Option<&Path> {
    static HOME_DIR: OnceLock<Option<PathBuf>> = OnceLock::new();

    let home = HOME_DIR.get_or_init(dirs::home_dir).as_deref()?;
    path.strip_prefix(home).ok()
}
